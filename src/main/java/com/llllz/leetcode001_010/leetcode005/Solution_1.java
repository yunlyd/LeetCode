package com.llllz.leetcode001_010.leetcode005;

/**
 * @create 2023-06-11-8:45
 */
public class Solution_1 {
    public String longestPalindrome(String s) {
        int len = s.length();  // 获取字符串s的长度
        if (len < 2) {  // 如果字符串长度小于2，即只有一个字符或为空字符串，直接返回s
            return s;
        }

        int maxLen = 1;  // 最长回文子串的长度，初始值为1
        int begin = 0;  // 最长回文子串的起始位置，初始值为0
// dp[i][j] 表示 s[i..j] 是否是回文串
/**
 * boolean[][] dp = new boolean[len][len];
 * 这行代码创建了一个二维布尔数组 dp，用于记录字符串 s 中子串的回文信息。
 *
 * 数组 dp 的大小为 len × len，其中 len 是字符串 s 的长度。
 * 数组 dp[i][j] 表示字符串 s 的第 i 到 j 个字符组成的子串是否为回文串。
 *
 * 初始时，所有的 dp[i][j] 元素都被初始化为 false，表示所有的子串都不是回文串。
 * 随后，通过动态规划的方式，根据已经计算得到的子串的回文信息来更新 dp 数组。
 */
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
/**
 * 下面这段代码是用来初始化布尔数组 dp 的对角线元素，即 dp[i][i]。
 * 循环 for (int i = 0; i < len; i++) 遍历从 0 到 len-1 的所有索引 i。
 * 在循环的每一次迭代中，代码 dp[i][i] = true;
 * 将布尔数组 dp 的第 i 行和第 i 列的元素设置为 true，表示长度为 1 的子串 s[i:i] 是回文串。
 * 这是因为长度为 1 的子串总是回文串，只包含一个字符。
 * 通过这段代码的执行，我们完成了布尔数组 dp 在对角线上的初始化，保证了所有长度为 1 的子串的回文信息都被正确记录在 dp 数组中。
 * 1代表布尔数据有值
 * 假如字符串为abcdefg
 *
 * a b 0 0 0 0 0
 * a b c 0 0 0 0
 * a b c d 0 0 0
 * a b c d e 0 0
 * a b c d e f 0
 * a b c d e f g
 *对角线上的元素长度为 1，是因为在这段代码中，我们要初始化的是所有长度为 1 的子串的回文信息。
 * 对角线上的元素 dp[i][i] 表示字符串 s 中索引 i 到索引 i 的子串，也就是长度为 1 的子串 s[i:i]。
 * 由于长度为 1 的子串只包含一个字符，它总是回文串，因此我们将其对应的 dp[i][i] 设置为 true，表示该子串是回文串。
 * 这样做的目的是为了初始化动态规划的边界条件，从而在后续的状态转移过程中能够正确地利用已知的回文信息。
 * 通过初始化长度为 1 的子串，我们可以在动态规划的过程中基于已知的回文信息来推导出更长子串的回文性质，最终找到最长的回文子串。
 * 需要注意的是，除了对角线上的元素以外，其他位置的元素表示的是不同长度的子串，需要通过动态规划的方式来计算其回文性质。
 */
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
/**
 * 这行代码将字符串 s 转换为字符数组 charArray。
 * 在Java中，字符串是不可变的，而字符数组是可变的。使用字符数组可以更方便地对字符串进行操作，例如访问和修改字符。
 * toCharArray() 是字符串类的一个方法，它将字符串转换为一个新的字符数组。
 * 在这行代码中，我们调用了 s.toCharArray()，将字符串 s 转换为字符数组，并将结果存储在变量 charArray 中。
 * 通过将字符串转换为字符数组，我们可以通过索引访问字符串中的每个字符，以及在需要修改字符串时，通过修改字符数组来实现。
 * 这在某些算法和操作中非常有用，因为字符数组的可变性使得操作更加灵活。
 */
        char[] charArray = s.toCharArray();


/**
 这段代码是核心的动态规划部分，用于计算最长回文子串的长度和起始位置。
 首先，通过一个双重循环来枚举所有可能的子串长度。外层循环的变量 L 表示子串的长度，从 2 开始递增，直到整个字符串的长度 len。
 内层循环的变量 i 表示左边界的起始位置，从 0 开始递增，直到整个字符串的长度 len。
 在每个子串长度和左边界的组合下，我们可以根据左边界 i 和长度 L 推导出右边界 j 的位置，通过公式 j = L + i - 1 来计算。
 如果右边界 j 超过了字符串的长度，就可以退出当前循环，因为后面的子串已经不需要再计算。
 接下来，我们比较子串的左右边界的字符是否相等。如果不相等，说明该子串不是回文串，将对应的 dp[i][j] 设置为 false。
 如果相等，根据子串长度的不同，有两种情况：
 如果子串长度小于 3（即 j - i < 3），那么该子串一定是回文串，将对应的 dp[i][j] 设置为 true。
 如果子串长度大于等于 3，那么判断子串的内部子串 dp[i + 1][j - 1] 是否为回文串，即判断去除两个边界字符后的子串是否为回文串。
 如果是回文串，将对应的 dp[i][j] 设置为 true，否则为 false。
 在每次更新 dp[i][j] 的时候，判断当前子串是否为回文串。
 如果是回文串且长度大于当前记录的最长回文子串长度 maxLen，则更新 maxLen 和起始位置 begin。
 最后，返回字符串 s 中起始位置为 begin、长度为 maxLen 的子串作为最长回文子串的结果。
 这段代码利用动态规划的思想，通过填充和利用子问题的解，逐步推导出更长子串的回文性质，从而找到最长的回文子串
 */
        // 递推开始
        // 先枚举子串长度,先从小的开始，所有字串长度为2的。
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，又边界的意思就是，拿2来说，长度为2的字串有很多，i为子串的左边界，随之而来的又边界为i+2-1
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}